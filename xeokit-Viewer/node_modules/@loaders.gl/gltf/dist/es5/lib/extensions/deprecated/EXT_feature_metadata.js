"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.decode = decode;
exports.name = void 0;
var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
var _gltfScenegraph = _interopRequireDefault(require("../../api/gltf-scenegraph"));
var EXT_FEATURE_METADATA = 'EXT_feature_metadata';
var name = EXT_FEATURE_METADATA;
exports.name = name;
function decode(_x) {
  return _decode.apply(this, arguments);
}
function _decode() {
  _decode = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee(gltfData) {
    var scenegraph;
    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          scenegraph = new _gltfScenegraph.default(gltfData);
          decodeExtFeatureMetadata(scenegraph);
        case 2:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return _decode.apply(this, arguments);
}
function decodeExtFeatureMetadata(scenegraph) {
  var _extension$schema;
  var extension = scenegraph.getExtension(EXT_FEATURE_METADATA);
  var schemaClasses = extension === null || extension === void 0 ? void 0 : (_extension$schema = extension.schema) === null || _extension$schema === void 0 ? void 0 : _extension$schema.classes;
  var featureTables = extension === null || extension === void 0 ? void 0 : extension.featureTables;
  var featureTextures = extension === null || extension === void 0 ? void 0 : extension.featureTextures;
  if (featureTextures) {
    console.warn('featureTextures is not yet supported in the "EXT_feature_metadata" extension.');
  }
  if (schemaClasses && featureTables) {
    for (var schemaName in schemaClasses) {
      var schemaClass = schemaClasses[schemaName];
      var featureTable = findFeatureTableByName(featureTables, schemaName);
      if (featureTable) {
        handleFeatureTableProperties(scenegraph, featureTable, schemaClass);
      }
    }
  }
}
function handleFeatureTableProperties(scenegraph, featureTable, schemaClass) {
  for (var propertyName in schemaClass.properties) {
    var _featureTable$propert;
    var schemaProperty = schemaClass.properties[propertyName];
    var featureTableProperty = featureTable === null || featureTable === void 0 ? void 0 : (_featureTable$propert = featureTable.properties) === null || _featureTable$propert === void 0 ? void 0 : _featureTable$propert[propertyName];
    var numberOfFeatures = featureTable.count;
    if (featureTableProperty) {
      var data = getPropertyDataFromBinarySource(scenegraph, schemaProperty, numberOfFeatures, featureTableProperty);
      featureTableProperty.data = data;
    }
  }
}
function getPropertyDataFromBinarySource(scenegraph, schemaProperty, numberOfFeatures, featureTableProperty) {
  var bufferView = featureTableProperty.bufferView;
  var data = scenegraph.getTypedArrayForBufferView(bufferView);
  switch (schemaProperty.type) {
    case 'STRING':
      {
        var stringOffsetBufferView = featureTableProperty.stringOffsetBufferView;
        var offsetsData = scenegraph.getTypedArrayForBufferView(stringOffsetBufferView);
        data = getStringAttributes(data, offsetsData, numberOfFeatures);
        break;
      }
    default:
  }
  return data;
}
function findFeatureTableByName(featureTables, schemaClassName) {
  for (var featureTableName in featureTables) {
    var featureTable = featureTables[featureTableName];
    if (featureTable.class === schemaClassName) {
      return featureTable;
    }
  }
  return null;
}
function getStringAttributes(data, offsetsData, stringsCount) {
  var stringsArray = [];
  var textDecoder = new TextDecoder('utf8');
  var stringOffset = 0;
  var bytesPerStringSize = 4;
  for (var index = 0; index < stringsCount; index++) {
    var stringByteSize = offsetsData[(index + 1) * bytesPerStringSize] - offsetsData[index * bytesPerStringSize];
    var stringData = data.subarray(stringOffset, stringByteSize + stringOffset);
    var stringAttribute = textDecoder.decode(stringData);
    stringsArray.push(stringAttribute);
    stringOffset += stringByteSize;
  }
  return stringsArray;
}
//# sourceMappingURL=EXT_feature_metadata.js.map