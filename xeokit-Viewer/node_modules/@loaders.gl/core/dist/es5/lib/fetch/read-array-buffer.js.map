{"version":3,"file":"read-array-buffer.js","names":["_loaderUtils","require","readArrayBuffer","_x","_x2","_x3","_readArrayBuffer","apply","arguments","_asyncToGenerator2","default","_regenerator","mark","_callee","file","start","length","slice","wrap","_callee$","_context","prev","next","fs","_readToArrayBuffer","abrupt","sent","Blob","readBlob","stop","_x4","_readBlob","_callee2","blob","_callee2$","_context2","Promise","resolve","reject","fileReader","FileReader","onload","event","_event$target","target","result","onerror","error","readAsArrayBuffer"],"sources":["../../../../src/lib/fetch/read-array-buffer.ts"],"sourcesContent":["//\nimport {fs} from '@loaders.gl/loader-utils';\n\n/**\n * Reads a chunk from a random access file\n * @param file\n * @param start\n * @param length\n * @returns\n */\nexport async function readArrayBuffer(\n  file: Blob | ArrayBuffer | string | number,\n  start: number,\n  length: number\n): Promise<ArrayBuffer> {\n  if (typeof file === 'number') {\n    return await fs._readToArrayBuffer(file, start, length);\n  }\n  // TODO - we can do better for ArrayBuffer and string\n  if (!(file instanceof Blob)) {\n    file = new Blob([file]);\n  }\n  const slice = file.slice(start, start + length);\n  return await readBlob(slice);\n}\n\n/**\n * Read a slice of a Blob or File, without loading the entire file into memory\n * The trick when reading File objects is to read successive \"slices\" of the File\n * Per spec https://w3c.github.io/FileAPI/, slicing a File only updates the start and end fields\n * Actually reading from file happens in `readAsArrayBuffer`\n * @param blob to read\n */\nexport async function readBlob(blob: Blob): Promise<ArrayBuffer> {\n  return await new Promise((resolve, reject) => {\n    const fileReader = new FileReader();\n    fileReader.onload = (event: ProgressEvent<FileReader>) =>\n      resolve(event?.target?.result as ArrayBuffer);\n    // TODO - reject with a proper Error\n    fileReader.onerror = (error: ProgressEvent<FileReader>) => reject(error);\n    fileReader.readAsArrayBuffer(blob);\n  });\n}\n"],"mappings":";;;;;;;;;;AACA,IAAAA,YAAA,GAAAC,OAAA;AAA4C,SAStBC,eAAeA,CAAAC,EAAA,EAAAC,GAAA,EAAAC,GAAA;EAAA,OAAAC,gBAAA,CAAAC,KAAA,OAAAC,SAAA;AAAA;AAAA,SAAAF,iBAAA;EAAAA,gBAAA,OAAAG,kBAAA,CAAAC,OAAA,EAAAC,YAAA,CAAAD,OAAA,CAAAE,IAAA,CAA9B,SAAAC,QACLC,IAA0C,EAC1CC,KAAa,EACbC,MAAc;IAAA,IAAAC,KAAA;IAAA,OAAAN,YAAA,CAAAD,OAAA,CAAAQ,IAAA,UAAAC,SAAAC,QAAA;MAAA,kBAAAA,QAAA,CAAAC,IAAA,GAAAD,QAAA,CAAAE,IAAA;QAAA;UAAA,MAEV,OAAOR,IAAI,KAAK,QAAQ;YAAAM,QAAA,CAAAE,IAAA;YAAA;UAAA;UAAAF,QAAA,CAAAE,IAAA;UAAA,OACbC,eAAE,CAACC,kBAAkB,CAACV,IAAI,EAAEC,KAAK,EAAEC,MAAM,CAAC;QAAA;UAAA,OAAAI,QAAA,CAAAK,MAAA,WAAAL,QAAA,CAAAM,IAAA;QAAA;UAGzD,IAAI,EAAEZ,IAAI,YAAYa,IAAI,CAAC,EAAE;YAC3Bb,IAAI,GAAG,IAAIa,IAAI,CAAC,CAACb,IAAI,CAAC,CAAC;UACzB;UACMG,KAAK,GAAGH,IAAI,CAACG,KAAK,CAACF,KAAK,EAAEA,KAAK,GAAGC,MAAM,CAAC;UAAAI,QAAA,CAAAE,IAAA;UAAA,OAClCM,QAAQ,CAACX,KAAK,CAAC;QAAA;UAAA,OAAAG,QAAA,CAAAK,MAAA,WAAAL,QAAA,CAAAM,IAAA;QAAA;QAAA;UAAA,OAAAN,QAAA,CAAAS,IAAA;MAAA;IAAA,GAAAhB,OAAA;EAAA,CAC7B;EAAA,OAAAP,gBAAA,CAAAC,KAAA,OAAAC,SAAA;AAAA;AAAA,SASqBoB,QAAQA,CAAAE,GAAA;EAAA,OAAAC,SAAA,CAAAxB,KAAA,OAAAC,SAAA;AAAA;AAAA,SAAAuB,UAAA;EAAAA,SAAA,OAAAtB,kBAAA,CAAAC,OAAA,EAAAC,YAAA,CAAAD,OAAA,CAAAE,IAAA,CAAvB,SAAAoB,SAAwBC,IAAU;IAAA,OAAAtB,YAAA,CAAAD,OAAA,CAAAQ,IAAA,UAAAgB,UAAAC,SAAA;MAAA,kBAAAA,SAAA,CAAAd,IAAA,GAAAc,SAAA,CAAAb,IAAA;QAAA;UAAAa,SAAA,CAAAb,IAAA;UAAA,OAC1B,IAAIc,OAAO,CAAC,UAACC,OAAO,EAAEC,MAAM,EAAK;YAC5C,IAAMC,UAAU,GAAG,IAAIC,UAAU,CAAC,CAAC;YACnCD,UAAU,CAACE,MAAM,GAAG,UAACC,KAAgC;cAAA,IAAAC,aAAA;cAAA,OACnDN,OAAO,CAACK,KAAK,aAALA,KAAK,wBAAAC,aAAA,GAALD,KAAK,CAAEE,MAAM,cAAAD,aAAA,uBAAbA,aAAA,CAAeE,MAAqB,CAAC;YAAA;YAE/CN,UAAU,CAACO,OAAO,GAAG,UAACC,KAAgC;cAAA,OAAKT,MAAM,CAACS,KAAK,CAAC;YAAA;YACxER,UAAU,CAACS,iBAAiB,CAACf,IAAI,CAAC;UACpC,CAAC,CAAC;QAAA;UAAA,OAAAE,SAAA,CAAAV,MAAA,WAAAU,SAAA,CAAAT,IAAA;QAAA;QAAA;UAAA,OAAAS,SAAA,CAAAN,IAAA;MAAA;IAAA,GAAAG,QAAA;EAAA,CACH;EAAA,OAAAD,SAAA,CAAAxB,KAAA,OAAAC,SAAA;AAAA"}