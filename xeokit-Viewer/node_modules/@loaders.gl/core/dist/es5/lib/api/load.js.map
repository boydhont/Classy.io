{"version":3,"file":"load.js","names":["_isType","require","_normalizeLoader","_getFetchFunction","_parse","load","_x","_x2","_x3","_x4","_load","apply","arguments","_asyncToGenerator2","default","_regenerator","mark","_callee","url","loaders","options","context","fetch","data","wrap","_callee$","_context","prev","next","Array","isArray","isLoaderObject","undefined","getFetchFunction","sent","isBlob","parse","abrupt","stop"],"sources":["../../../../src/lib/api/load.ts"],"sourcesContent":["import type {DataType, Loader, LoaderContext, LoaderOptions} from '@loaders.gl/loader-utils';\nimport {isBlob} from '../../javascript-utils/is-type';\nimport {isLoaderObject} from '../loader-utils/normalize-loader';\nimport {getFetchFunction} from '../loader-utils/get-fetch-function';\n\nimport {parse} from './parse';\n\n/**\n * Parses `data` using a specified loader\n * Note: Load does duplicate a lot of parse.\n * it can also call fetchFile on string urls, which `parse` won't do.\n * @param data\n * @param loaders\n * @param options\n * @param context\n */\n// implementation signature\nexport async function load(\n  url: string | DataType,\n  loaders?: Loader | Loader[] | LoaderOptions,\n  options?: LoaderOptions,\n  context?: LoaderContext\n): Promise<any> {\n  // Signature: load(url, options)\n  if (!Array.isArray(loaders) && !isLoaderObject(loaders)) {\n    context = undefined; // context not supported in short signature\n    options = loaders as LoaderOptions;\n    loaders = undefined;\n  }\n\n  // Select fetch function\n  const fetch = getFetchFunction(options);\n\n  // at this point, `url` could be already loaded binary data\n  let data = url;\n  // url is a string, fetch the url\n  if (typeof url === 'string') {\n    data = await fetch(url);\n    // URL is Blob or File, fetchFile handles it (alt: we could generate ObjectURL here)\n  }\n\n  if (isBlob(url)) {\n    // The fetch response object will contain blob.name\n    // @ts-expect-error TODO - This may not work for overridden fetch functions\n    data = await fetch(url);\n  }\n\n  // Data is loaded (at least we have a `Response` object) so time to hand over to `parse`\n  return await parse(data, loaders as Loader[], options);\n}\n"],"mappings":";;;;;;;;;AACA,IAAAA,OAAA,GAAAC,OAAA;AACA,IAAAC,gBAAA,GAAAD,OAAA;AACA,IAAAE,iBAAA,GAAAF,OAAA;AAEA,IAAAG,MAAA,GAAAH,OAAA;AAA8B,SAYRI,IAAIA,CAAAC,EAAA,EAAAC,GAAA,EAAAC,GAAA,EAAAC,GAAA;EAAA,OAAAC,KAAA,CAAAC,KAAA,OAAAC,SAAA;AAAA;AAAA,SAAAF,MAAA;EAAAA,KAAA,OAAAG,kBAAA,CAAAC,OAAA,EAAAC,YAAA,CAAAD,OAAA,CAAAE,IAAA,CAAnB,SAAAC,QACLC,GAAsB,EACtBC,OAA2C,EAC3CC,OAAuB,EACvBC,OAAuB;IAAA,IAAAC,KAAA,EAAAC,IAAA;IAAA,OAAAR,YAAA,CAAAD,OAAA,CAAAU,IAAA,UAAAC,SAAAC,QAAA;MAAA,kBAAAA,QAAA,CAAAC,IAAA,GAAAD,QAAA,CAAAE,IAAA;QAAA;UAGvB,IAAI,CAACC,KAAK,CAACC,OAAO,CAACX,OAAO,CAAC,IAAI,CAAC,IAAAY,+BAAc,EAACZ,OAAO,CAAC,EAAE;YACvDE,OAAO,GAAGW,SAAS;YACnBZ,OAAO,GAAGD,OAAwB;YAClCA,OAAO,GAAGa,SAAS;UACrB;UAGMV,KAAK,GAAG,IAAAW,kCAAgB,EAACb,OAAO,CAAC;UAGnCG,IAAI,GAAGL,GAAG;UAAA,MAEV,OAAOA,GAAG,KAAK,QAAQ;YAAAQ,QAAA,CAAAE,IAAA;YAAA;UAAA;UAAAF,QAAA,CAAAE,IAAA;UAAA,OACZN,KAAK,CAACJ,GAAG,CAAC;QAAA;UAAvBK,IAAI,GAAAG,QAAA,CAAAQ,IAAA;QAAA;UAAA,KAIF,IAAAC,cAAM,EAACjB,GAAG,CAAC;YAAAQ,QAAA,CAAAE,IAAA;YAAA;UAAA;UAAAF,QAAA,CAAAE,IAAA;UAAA,OAGAN,KAAK,CAACJ,GAAG,CAAC;QAAA;UAAvBK,IAAI,GAAAG,QAAA,CAAAQ,IAAA;QAAA;UAAAR,QAAA,CAAAE,IAAA;UAAA,OAIO,IAAAQ,YAAK,EAACb,IAAI,EAAEJ,OAAO,EAAcC,OAAO,CAAC;QAAA;UAAA,OAAAM,QAAA,CAAAW,MAAA,WAAAX,QAAA,CAAAQ,IAAA;QAAA;QAAA;UAAA,OAAAR,QAAA,CAAAY,IAAA;MAAA;IAAA,GAAArB,OAAA;EAAA,CACvD;EAAA,OAAAP,KAAA,CAAAC,KAAA,OAAAC,SAAA;AAAA"}